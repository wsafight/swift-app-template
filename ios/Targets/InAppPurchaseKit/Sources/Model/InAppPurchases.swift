//
//  InAppPurchases.swift
//  InAppPurchaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/inapppurchasekit
//

import AnalyticsKit
import RevenueCat
import SharedKit
import SwiftUI

public enum SubscriptionState: String {
	case notSubscribed = "not subscribed"
	case subscribed = "subscribed"
}

public class InAppPurchases: ObservableObject {

	@Published public private(set) var subscriptionState: SubscriptionState = .notSubscribed

	public init() {
		Task {
			if Purchases.isConfigured {
				await listenForSubscriptionStateChange()
			} else {
				print(
					"[IAPKIT] ERROR: RevenueCat is not configured. Accessing RevenueCat features will not work or may crash the app."
				)
			}
		}
	}

	@MainActor
	private func listenForSubscriptionStateChange() async {
		// handle any changes to customerInfo
		for try await customerInfo in Purchases.shared.customerInfoStream {
			withAnimation {
				subscriptionState = Self.extractSubscriptionStatus(customerInfo)
				Analytics.capture(
					.info, id: "iap_state_change",
					longDescription: "Subscription status changed to: \(subscriptionState.rawValue)",
					source: .iap)
			}
		}
	}

	/// See if the premium entitlement can be found in the provided customer information and return the subscription state depending on that
	static public func extractSubscriptionStatus(_ customerInfo: CustomerInfo) -> SubscriptionState {
		if let premiumEntitlement = customerInfo.entitlements.all[Constants.InAppPurchases.premiumEntitlementIdentifier] {
			if premiumEntitlement.isActive {
				return .subscribed
			}
		}
		return .notSubscribed
	}

	static public func showSubscriptionManagementScreen() async {
		do {
			try await Purchases.shared.showManageSubscriptions()
			Analytics.capture(
				.info, id: "showing_manage_subs", longDescription: "Manage Subscriptions screen shown",
				source: .iap)
		} catch {
			Analytics.capture(
				.error, id: "show_manage_subs",
				longDescription: "Error showing Manage Subscriptions screen: \(error.localizedDescription)",
				source: .iap)
		}
	}

	/// Will extract all the relevant data out of CustomerInfo and return it as a dictionary that we will use for analytics
	static public func convertCustomerInfoToAnalyticsUserProperties(_ customerInfo: CustomerInfo) -> [String: Any] {
		var userProperties: [String: Any] = [:]
		userProperties["iap_premium_access"] = InAppPurchases.extractSubscriptionStatus(customerInfo) == .subscribed
		userProperties["iap_first_seen"] = customerInfo.firstSeen
		return userProperties
	}

}

//MARK: - Helper functions for Actions Based on Premium Access

/// If a function is called via executeIfGotPremium, what to do if the user doesn't have premium access
public enum NoPremiumConsequence {
	/// Just show a notification, telling the user they have no access, with the ability to tap to show the paywall sheet
	case showInAppNotification

	/// Show the paywall sheet
	case showPaywall
}

//  https://docs.swiftylaun.ch/module/inapppurchasekit/lock-actions-behind-paywall
extension InAppPurchases {

	/// Perform an action only if the user got premium. Otherwise show an in-app notification or show the paywall
	public func executeIfGotPremium(otherwise consequence: NoPremiumConsequence = .showPaywall, _ closure: () -> Void) {
		guard subscriptionState == .subscribed else {
			_consequenceExecutionForNoPremiumAccess(consequence)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if the user got premium. Otherwise show an in-app notification or show the paywall
	public func executeIfGotPremium(otherwise consequence: NoPremiumConsequence = .showPaywall, _ closure: () async -> Void)
		async
	{
		guard subscriptionState == .subscribed else {
			_consequenceExecutionForNoPremiumAccess(consequence)
			return
		}
		await closure()
	}

	/// Internal function for the above functionality
	private func _consequenceExecutionForNoPremiumAccess(_ consequence: NoPremiumConsequence) {
		if consequence == .showInAppNotification {
			showInAppNotification(
				content: .init(title: "Premium Required", message: "Tap here to purchase Premium"),
				style: .init(sfSymbol: "star.fill", symbolColor: .indigo, size: .compact)
			) {
				InAppPurchases.showPaywallSheet()
			}
		} else {
			InAppPurchases.showPaywallSheet()
		}
	}
}

///For SDK Initialization
extension InAppPurchases {

	// We dont do this inside init of InAppPurchases because we don't want to init RC every time we initialize
	// the InAppPurchases object. Otherwise we will a new InAppPurchases object inside something like a SwiftUI Preview,
	// which call this function again and again, and make everything pretty sloooow...
	// Is only used once in App.swift to initialize RevenueCat
	public static func initRevenueCat() {
		guard let apiKey = try? getPlistEntry("REVENUECAT_API_KEY", in: "RevenueCat-Info"), !apiKey.isEmpty else {
			fatalError("ERROR: Couldn't find REVENUECAT_API_KEY in RevenueCat-Info.plist!")
		}
		Purchases.logLevel = .error
		Purchases.configure(withAPIKey: apiKey)
	}

	/// Allows us to connect a user with our Firebase Auth UID
	/// Will call completion regardless of success or failure. Just on success, resultingUserProperties will contain the updated user properties with RevenueCat information.
	static public func associateUserWithID(
		_ id: String, currentUserProperties: [String: Any],
		completion: @escaping (_ resultingUserProperties: [String: Any]) -> Void
	) {
		var userProperties = currentUserProperties
		Purchases.shared.logIn(id) { info, isCreated, error in
			if let error {
				Analytics.capture(
					.error, id: "connect_user_between_auth_and_rc",
					longDescription:
						"[RC<>AUTH] Auth and IAP Connection Error for User with ID \(id): \(error.localizedDescription) ",
					source: .iap)
			} else {
				Analytics.capture(
					.info, id: "connected_user_between_auth_and_rc",
					longDescription: "[RC<>AUTH] Connected Auth and IAP for User with ID \(id).", source: .iap
				)
			}
			if let customerInfo = info {
				let rcAssociatedUserProperties = InAppPurchases.convertCustomerInfoToAnalyticsUserProperties(
					customerInfo)

				// Add RevenueCat Information to User Properties
				userProperties = userProperties.merging(rcAssociatedUserProperties) { (current, _) in current }
			}
			completion(userProperties)
		}
	}

	/// Disconnects RevenueCat ID from Firebase Auth User ID
	static public func removeUserIDAssociation() {
		let previousAppUserID = Purchases.shared.appUserID
		if !Purchases.shared.isAnonymous {  // only do that if the user was connected before, otherwise, we'll get an error
			Purchases.shared.logOut { info, error in
				if let error {
					Analytics.capture(
						.error, id: "disconnect_user_between_auth_and_rc",
						longDescription:
							"[RC<>AUTH] Auth and IAP Disconnection Error for User with ID \(previousAppUserID): \(error.localizedDescription) ",
						source: .iap)
				} else {
					Analytics.capture(
						.info, id: "disconnected_user_between_auth_and_rc",
						longDescription:
							"[RC<>AUTH] Disconnected Auth and IAP for User with ID \(previousAppUserID).",
						source: .iap)
				}
			}
		}
	}

}
