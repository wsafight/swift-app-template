//
//  AuthGeneral.swift
//  FirebaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit
//

import AnalyticsKit
import FirebaseAuth
import SharedKit

//MARK: - Auth Stuff (General)
extension DB {

	// Firebase calls this function when user state changes
	func registerAuthStateListener() {
		if authStateHandler == nil {
			authStateHandler = Auth.auth().addStateDidChangeListener { auth, user in
				Analytics.capture(
					.info,
					id: "auth_state_change",
					longDescription:
						"New User State: \(user == nil ? "Logged Out" : "Logged In (\(user!.isEmailVerified ? "Email Verified" : "Email Not Verified"))")",
					source: .auth
				)
				self.currentUser = user
				self.setUserData(user: user)
			}
		}
	}

	public func signOut() throws {
		Analytics.capture(.info, id: "sign_out_called", source: .auth)
		do {
			try Auth.auth().signOut()
		} catch {
			Analytics.capture(
				.error, id: "sign_out", longDescription: "Error signing out: \(error.localizedDescription)",
				source: .auth)
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultSignOutError)
		}
	}

	public func deleteUser() async throws {
		Analytics.capture(.info, id: "delete_user_called", source: .auth)

		guard let currentUser = currentUser, let provider = currentUserProvider else {
			let error = AuthKitError.noUserSignedIn
			error.sendToAnalytics(longDescription: "Error deleting user: No user signed in.")
			throw error
		}

		// Some extra steps are needed to delete a user using Sign in with Apple
		// See https://firebase.google.com/docs/auth/ios/apple#token_revocation
		if provider == .apple {
			try await revokeAppleToken()
		}

		do {
			try await currentUser.delete()
			let userID = currentUser.uid
			try signOut()
			Analytics.capture(
				.success, id: "delete_user", longDescription: "Deleted User with id: \(userID)", source: .auth)
		} catch {
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultUserDeletionError)
		}
	}

	// Takes in user data and sets all the variables
	private func setUserData(user: User?) {
		if let user = user {
			self.authState = user.isEmailVerified ? .signedIn : .signedInUnverified
			if user.providerData.count > 0 {
				let provider = user.providerData[0].providerID
				if provider == "password" {
					self.currentUserProvider = .email
				} else if provider == "apple.com" {
					self.currentUserProvider = .apple
				} else {
					self.currentUserProvider = nil
				}
			}
		} else {
			self.authState = .signedOut
			self.currentUserProvider = nil
		}
	}

	// Will refresh user data and update all the variables
	// Can fail, but we wont throw an error
	public func refreshUserData() async {
		Analytics.capture(.info, id: "refresh_user_data_called", source: .auth)
		guard let user = currentUser else {
			let error = AuthKitError.noUserSignedIn
			error.sendToAnalytics(longDescription: "Error refreshing user data: No user signed in.")
			return
		}

		do {
			try await user.reload()
			setUserData(user: user)
			Analytics.capture(.success, id: "refresh_user_data", source: .auth)
		} catch {
			let error = AuthKitError.defaultUserDataRefreshError
			error.sendToAnalytics(longDescription: "Error refreshing user data: \(error.localizedDescription)")
			return
		}

	}

	public func newDisplayName(_ name: String) async throws {
		Analytics.capture(.info, id: "new_display_name_called", source: .auth)
		guard let currentUser = self.currentUser else {
			let error = AuthKitError.noUserSignedIn
			error.sendToAnalytics(longDescription: "Error updating user display name: No user signed in.")
			throw error
		}
		let changeRequest = currentUser.createProfileChangeRequest()
		changeRequest.displayName = name
		do {
			try await changeRequest.commitChanges()
			await refreshUserData()
			Analytics.capture(
				.success, id: "new_display_name", longDescription: "Display name updated to \(name).",
				source: .auth)
		} catch {
			let error = AuthKitError.defaultUserNameUpdateError
			error.sendToAnalytics(longDescription: "Error updating user display name: \(error)")
			throw error
		}
	}

	// Use this function to upload the new user profile picture
	// You can use imgur, s3, cloud storage or other services
	// use this as reference point: https://firebase.google.com/docs/storage/ios/upload-files
	// and this: https://developer.apple.com/documentation/photokit/bringing_photos_picker_to_your_swiftui_app
	public func newUserProfilePic(_ img: String) async {

	}

	/// Will extract all the relevant data out of User and return it as a dictionary that we will use for analytics
	static public func convertAuthUserToAnalyticsUserProperties(_ user: User) -> [String: Any] {
		var userProperties: [String: Any] = [:]
		userProperties["name"] = user.displayName ?? "Unknown"
		userProperties["email"] = user.email ?? "Unknown"
		userProperties["signin_method"] = user.providerData.first?.providerID ?? "Unknown"
		userProperties["verified"] = user.isEmailVerified
		return userProperties
	}
}

//MARK: - Helper functions for Auth-based actions

/// If a function is called via executeIfSignedIn, what to do if the user is not signed in
public enum NotSignedInConsequence {
	/// Just show a notification, telling the user they are not signed in
	case showInAppNotification

	/// Or show the sign in screen
	case showSignInScreen
}

extension DB {

	/// Perform an action only if a user is signed in. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () -> Void
	) {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if a user is signed in. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () async -> Void
	) async {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		await closure()
	}

	/// Perform an action only if a user is signed in as a user with userID. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		withUserID userID: String?,
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () -> Void
	) {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		guard userID != nil && userID == currentUser?.uid else {
			showInAppNotification(
				.error,
				content: .init(
					title: "Access Forbidden",
					message: "You can't perform this action."),
				size: .compact
			)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if a user is signed in as a user with userID. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		withUserID userID: String?,
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () async -> Void
	) async {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		guard userID != nil && userID == currentUser?.uid else {
			showInAppNotification(
				.error,
				content: .init(
					title: "Access Forbidden",
					message: "You can't perform this action."),
				size: .compact
			)
			return
		}
		await closure()
	}

	/// Internal function for the above functionality
	private func _consequenceExecutionForNotSignedIn(_ consequence: NotSignedInConsequence) {
		if consequence == .showInAppNotification {
			showInAppNotification(
				.error, content: .init(title: "Sign In Required", message: "Can't perform this action"),
				size: .compact)
		} else {
			showSignInSheet()
		}
	}
}
