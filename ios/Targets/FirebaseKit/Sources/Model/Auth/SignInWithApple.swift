//
//  SignInWithApple.swift
//  FirebaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/authkit/sign-in-with-apple-flow
//

import AnalyticsKit
import AuthenticationServices
import CryptoKit
import FirebaseAuth

// MARK: - Sign in with Apple
extension DB {

	public func handleSignInWithAppleRequest(_ request: ASAuthorizationAppleIDRequest) {
		request.requestedScopes = [.fullName, .email]
		let nonce = randomNonceString()
		currentNonce = nonce
		request.nonce = sha256(nonce)
	}

	/// Throws if there is an error
	/// Return false if the user canceled sign in
	/// Returns true if sign in was sucessful
	public func handleSignInWithAppleCompletion(_ result: Result<ASAuthorization, Error>) async throws -> Bool {
		Analytics.capture(.info, id: "handle_sign_in_with_apple_completion_called", source: .auth)
		if case .failure(let failure) = result {
			if (failure as? ASAuthorizationError)?.code == .canceled {
				Analytics.capture(
					.info,
					id: "handle_sign_in_with_apple_completion",
					longDescription: "SignInWithApple Info: User cancelled Apple Sign In.",
					source: .auth
				)
				return false
			}
			Analytics.capture(
				.error,
				id: "handle_sign_in_with_apple_completion",
				longDescription: "SignInWithApple Error: \(failure.localizedDescription)",
				source: .auth
			)
			throw AuthKitError.defaultSignInWithAppleError
		}
		if case .success(let authResults) = result {

			guard let appleIDCredential = authResults.credential as? ASAuthorizationAppleIDCredential else {
				Analytics.capture(
					.error,
					id: "handle_sign_in_with_apple_completion",
					longDescription: "SignInWithApple Error: Invalid authorization result.",
					source: .auth
				)
				throw AuthKitError.defaultSignInWithAppleError
			}

			self.appleIDCredential = appleIDCredential
			guard let nonce = currentNonce else {
				Analytics.capture(
					.error,
					id: "handle_sign_in_with_apple_completion",
					longDescription:
						"SignInWithApple Error: Invalid state: A login callback was received, but no login request was sent.",
					source: .auth
				)
				fatalError(
					"[AUTH][APPLE][ERROR]: Invalid state: A login callback was received, but no login request was sent."
				)
			}
			guard let appleIDToken = appleIDCredential.identityToken else {
				Analytics.capture(
					.error,
					id: "handle_sign_in_with_apple_completion",
					longDescription: "SignInWithApple Error: Unable to fetch identity token",
					source: .auth
				)
				throw AuthKitError.defaultSignInWithAppleError
			}
			guard let idTokenString = String(data: appleIDToken, encoding: .utf8) else {
				Analytics.capture(
					.error,
					id: "handle_sign_in_with_apple_completion",
					longDescription:
						"SignInWithApple Error: Unable to serialize token string from data: \(appleIDToken.debugDescription)",
					source: .auth
				)
				throw AuthKitError.defaultSignInWithAppleError
			}
			let credential = OAuthProvider.credential(
				withProviderID: "apple.com",
				idToken: idTokenString,
				rawNonce: nonce
			)
			do {
				let result = try await Auth.auth().signIn(with: credential)
				Analytics.capture(.success, id: "handle_sign_in_with_apple_completion", source: .auth)
				await updateDisplayName(for: result.user, with: appleIDCredential)
				return true
			} catch {
				Analytics.capture(
					.error,
					id: "handle_sign_in_with_apple_completion",
					longDescription: "SignInWithApple Firebase Error: \(error.localizedDescription)",
					source: .auth
				)
				throw AuthKitError.defaultSignInWithAppleError
			}
		}

		// Fallback -> do as if the user canceled
		return false
	}

	// Firebase doesn't automatically update the displayName, so we have to do it manually (For Sign in With Apple)
	private func updateDisplayName(for user: User, with appleIDCredential: ASAuthorizationAppleIDCredential) async {
		if let currentDisplayName = Auth.auth().currentUser?.displayName, !currentDisplayName.isEmpty {
			print("[AUTH][APPLE][INFO] Display Name already exists, not updating")
		} else {
			var name = ""
			if let givenName = appleIDCredential.fullName?.givenName {
				name += givenName
			}
			if let familyName = appleIDCredential.fullName?.familyName {
				name += " \(familyName)"
			}

			if name.isEmpty {
				name = "USER NAME"
			}

			let changeRequest = user.createProfileChangeRequest()
			changeRequest.displayName = name
			do {
				try await changeRequest.commitChanges()
				let displayName = Auth.auth().currentUser?.displayName ?? "NO_NAME"
				await refreshUserData()
				Analytics.capture(
					.success, id: "update_name_after_signin_with_apple",
					longDescription: "User Name updated to: \(displayName)", source: .auth)
			} catch {
				Analytics.capture(
					.error, id: "update_name_after_signin_with_apple",
					longDescription:
						"An error occurred when trying to set the display name: \(error.localizedDescription)",
					source: .auth)
			}
		}
	}

	private func randomNonceString(length: Int = 32) -> String {
		precondition(length > 0)
		var randomBytes = [UInt8](repeating: 0, count: length)
		let errorCode = SecRandomCopyBytes(kSecRandomDefault, randomBytes.count, &randomBytes)
		if errorCode != errSecSuccess {
			Analytics.capture(
				.error, id: "random_nonce_generation",
				longDescription: "Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)",
				source: .auth)
			fatalError(
				"[AUTH][APPLE][ERROR] Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)"
			)
		}

		let charset: [Character] =
			Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")

		let nonce = randomBytes.map { byte in
			// Pick a random character from the set, wrapping around if needed.
			charset[Int(byte) % charset.count]
		}

		return String(nonce)
	}

	private func sha256(_ input: String) -> String {
		let inputData = Data(input.utf8)
		let hashedData = SHA256.hash(data: inputData)
		let hashString = hashedData.compactMap {
			String(format: "%02x", $0)
		}.joined()
		return hashString
	}

	// Needed in order to properly delete accounts that use Sign in With Apple
	// See https://firebase.google.com/docs/auth/ios/apple#token_revocation
	internal func revokeAppleToken() async throws {
		Analytics.capture(.info, id: "delete_user_additional_apple_steps", source: .auth)
		guard let appleIDCredential = appleIDCredential else {
			Analytics.capture(
				.error,
				id: "delete_user_additional_apple_steps",
				longDescription: "AppleID Credential is NIL.",
				source: .auth
			)
			throw AuthKitError.defaultUserDeletionError
		}

		guard let _ = currentNonce else {
			Analytics.capture(
				.error,
				id: "delete_user_additional_apple_steps",
				longDescription: "Current NONCE is NIL. ReAuth Needed.",
				source: .auth
			)
			throw AuthKitError.defaultUserDeletionError
		}

		guard let appleAuthCode = appleIDCredential.authorizationCode else {
			Analytics.capture(
				.error, id: "delete_user_additional_apple_steps",
				longDescription: "Apple ID Credential Auth Code is NIL.",
				source: .auth
			)
			throw AuthKitError.defaultUserDeletionError
		}

		guard let authCodeString = String(data: appleAuthCode, encoding: .utf8) else {
			Analytics.capture(
				.error,
				id: "delete_user_additional_apple_steps",
				longDescription:
					"Couldn't Serialize Apple ID Credential Auth Code to String: \(appleAuthCode.debugDescription)",
				source: .auth
			)
			throw AuthKitError.defaultUserDeletionError
		}

		do {
			try await Auth.auth().revokeToken(withAuthorizationCode: authCodeString)
			Analytics.capture(.success, id: "delete_user_additional_apple_steps", source: .auth)
		} catch {
			Analytics.capture(
				.error,
				id: "delete_user_additional_apple_steps",
				longDescription: "Error revoking token: \(error.localizedDescription)",
				source: .auth

			)
			throw AuthKitError.defaultUserDeletionError
		}
	}

}
