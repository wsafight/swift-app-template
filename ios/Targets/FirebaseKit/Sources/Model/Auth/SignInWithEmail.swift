//
//  SignInWithEmail.swift
//  FirebaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/authkit/email-sign-in-flow
//

import AnalyticsKit
import FirebaseAuth

// MARK: - Sign in via Email/Password
extension DB {

	public func signIn(email: String, password: String) async throws {
		Analytics.capture(.info, id: "sign_in_via_email_called", source: .auth)
		do {
			//This doesn't throw "invalid email address" or "invalid password" because it can
			//be abused by fraudsters via automated trial-end-error attacks. See https://stackoverflow.com/a/77312743/12596719
			//This is why the error message may be vague to the user
			let result = try await Auth.auth().signIn(withEmail: email, password: password)
			self.currentUser = result.user
			Analytics.capture(
				.success, id: "sign_in_via_email",
				longDescription: "User Successfully signed in with email: \(result.user.email ?? "UNAVAILABLE").",
				source: .auth)
		} catch {
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultSignInWithEmailError)
		}
	}

	public func signUp(email: String, password: String) async throws {
		Analytics.capture(.info, id: "sign_up_via_email_called", source: .auth)
		do {
			let result = try await Auth.auth().createUser(withEmail: email, password: password)
			self.currentUser = result.user
			try await newDisplayName(randomNicknameGenerator())
			do {  //even if sending email verification fails, we want to continue with the sign up process (account created, just need to verify email)
				try await sendVerificationEmail()
			} catch {
				if let authError = (error as? AuthErrorCode)?.asAuthKitError {
					authError.sendToAnalytics(longDescription: error.localizedDescription)
				}
				Analytics.capture(
					.error, id: "email_signup_send_verification_mail",
					longDescription: "There was an error sending verification Email during signup",
					source: .auth)
			}

			Analytics.capture(
				.success, id: "sign_up_via_email",
				longDescription:
					"Account successfully created with email: \(result.user.email ?? "UNAVAILABLE").",
				source: .auth)
		} catch {
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultSignUpWithEmailError)
		}
	}

	public func sendVerificationEmail() async throws {
		Analytics.capture(.info, id: "send_verification_email_called", source: .auth)
		guard let user = currentUser else {
			let error = AuthKitError.noUserSignedIn
			error.sendToAnalytics(longDescription: "Verification Email Error: No user is currently signed in.")
			throw error
		}
		do {
			try await user.sendEmailVerification()
			Analytics.capture(
				.success, id: "send_verification_email", longDescription: "Email: \(user.email ?? "UNAVAILABLE")",
				source: .auth)
		} catch {
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultSendVerificationEmailError)
		}
	}

	///Will send an email to that email address with a link to a reset password site
	public func requestPasswordReset(email: String) async throws {
		Analytics.capture(.info, id: "request_password_reset_called", source: .auth)
		do {
			try await Auth.auth().sendPasswordReset(withEmail: email)
			Analytics.capture(
				.success, id: "request_password_reset", longDescription: "Password Reset Email sent to: \(email)",
				source: .auth)
		} catch {
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultResetPasswordError)
		}

	}

	public func setNewPassword(_ newPassword: String) async throws {
		Analytics.capture(.info, id: "set_new_password_called", source: .auth)
		guard let user = currentUser else {
			let error = AuthKitError.noUserSignedIn
			error.sendToAnalytics(longDescription: "Password Update Error: No user is currently signed in.")
			throw error
		}

		guard currentUserProvider == .email else {
			let error = AuthKitError.defaultNewPasswordError
			// #SWIFTYLAUNCHENDIF
			error.sendToAnalytics(longDescription: "Password Update Error: Current Provider Not Email")
			throw error
		}

		guard newPassword.validate([.atLeast8Chars, .onlyAllowedChars, .requiresAtLeastOneSpecialChar]) == nil else {
			let error = AuthKitError.weakPassword
			error.sendToAnalytics(longDescription: "Password Update Error: Password does not meet requirements.")
			throw error
		}

		do {
			try await user.updatePassword(to: newPassword)
			Analytics.capture(
				.success, id: "set_new_password", longDescription: "Updated User Password.", source: .auth)
		} catch {
			try handleFirebaseError(error: error, defaultAuthKitError: .defaultNewPasswordError)
		}

	}
}

// MARK: - Misc Functions
extension DB {

	/// Will generate a random nickname on account creation
	func randomNicknameGenerator() -> String {

		let nicknameAdjectives = [
			"Fluffy", "Wacky", "Squishy", "Zany", "Quirky", "Goofy", "Sneaky", "Funky", "Gooey", "Greasy",
			"Loony", "Slippery", "Spooky", "Sassy", "Zippy", "Bouncy", "Crusty", "Squiggly", "Wonky", "Fuzzy",
			"Grumpy", "Snappy", "Sloppy", "Spiky", "Jumpy", "Shiny", "Clumsy", "Snazzy", "Twisty", "Lumpy",
			"Chunky", "Frisky", "Plucky", "Punky", "Zappy", "Giddy", "Pudgy", "Wobbly", "Slinky", "Snarky",
			"Muddy", "Bubbly", "Scrappy", "Dingy", "Sparkly", "Flaky", "Sleeky", "Weird", "Globby", "Blurpy",
			"Squirmy", "Whacky", "Gloomy", "Dopey", "Chewy", "Loopy", "Tricky", "Smelly", "Puffy", "Blurry",
			"Munchy", "Beefy", "Smokey", "Soggy", "Rusty", "Dusty", "Musty", "Frosty", "Cloudy", "Peppy",
			"Cranky", "Droopy", "Flimsy", "Sappy", "Gritty", "Jiggly", "Skippy", "Lanky", "Mopey", "Sizzly",
			"Twitchy", "Swirly", "Flicky", "Dizzy", "Scoopy", "Whimsy", "Glitzy", "Sneaky", "Croaky", "Blinky",
			"Daffy", "Flappy", "Sloshy", "Mushy", "Prickly", "Wiggly", "Hasty", "Crafty", "Juicy", "Nifty",
			"Zesty", "Saucy", "Peachy", "Cuddly", "Raggedy", "Roly-Poly", "Gawky", "Cheeky", "Freaky", "Lofty",
			"Groggy", "Nippy", "Pouty", "Snooty", "Tickly", "Tangy", "Wheezy", "Slinky", "Crinkly", "Splotchy",
			"Squishy", "Whirly", "Quacky", "Fluffy", "Gumpy", "Slinky", "Scratchy", "Spritely", "Spunky", "Snuggly",
		]

		let nicknameNouns = [
			"Noodle", "Pickle", "Wombat", "Goblin", "Muffin", "Nugget", "Zombie", "Cupcake", "Penguin", "Taco",
			"Banana", "Rascal", "Cheese", "Robot", "Wizard", "Potato", "Chicken", "Jelly", "Butter", "Dragon",
			"Hamster", "Pirate", "Monkey", "Kitten", "Puppy", "Panda", "Unicorn", "Llama", "Duckling", "Burrito",
			"Buffalo", "Gorilla", "Mermaid", "Narwhal", "Sasquatch", "Alien", "Koala", "Squirrel", "Dinosaur",
			"Octopus",
			"Hedgehog", "Vampire", "Werewolf", "Zebra", "Yak", "Troll", "Snail", "Lobster", "Kangaroo", "Flamingo",
			"Cheetah", "Chimpanzee", "Badger", "Ferret", "Giraffe", "Jellyfish", "Koala", "Leopard", "Meerkat",
			"Newt",
			"Ostrich", "Parrot", "Quokka", "Raccoon", "Sloth", "Tiger", "Urchin", "Vulture", "Walrus", "Xerus",
			"Yeti", "Zebu", "Axolotl", "Baboon", "Camel", "Duck", "Eel", "Falcon", "Gecko", "Hyena", "Iguana",
			"Jackal", "Kiwi", "Lemur", "Mongoose", "Numbat", "Orangutan", "Peacock", "Quail", "Rabbit", "Shark",
			"Toucan", "Uakari", "Viper", "Weasel", "Xiphosuran", "Yak", "Zorilla", "Bobcat", "Capybara", "Dingo",
			"Echidna", "Frog", "Gnu", "Hippo", "Impala", "Jaguar", "Kraken", "Lynx", "Mammoth", "Narwhal", "Ocelot",
			"Platypus", "Quoll", "Rhinoceros", "Seal", "Tapir", "Umbrellabird", "Vicuna", "Wolverine", "Yabby",
			"Zorilla",
		]

		return "\(nicknameAdjectives.randomElement()!)\(nicknameNouns.randomElement()!)"
	}
}
