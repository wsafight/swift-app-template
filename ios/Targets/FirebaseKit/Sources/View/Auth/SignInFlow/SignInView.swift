//
//  SignInView.swift
//  FirebaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit/email-sign-in-flow
//  https://docs.swiftylaun.ch/module/authkit/sign-in-with-apple-flow
//

import AnalyticsKit
import AuthenticationServices
import SharedKit
import SwiftUI

enum SignInFlowPath: Hashable {
	case emailSignUp  // Sign Up via Email Screen
	case confirmEmail  // User Must Confirm Email Screen
	case forgotPassword  // User Forgot Password Screen
}

/// This view prompts the user to sign in.
/// We show this when a view has a .requireLogin() modifier and the user is not signed in
public struct SignInView: View {

	@ObservedObject var db: DB

	@State var signInFlowPath: NavigationPath
	let navTitle: LocalizedStringKey

	/// Calls this when the user is signed in
	/// Useful when displayed modally to dismiss the Login View.
	let onSignedIn: () -> Void

	let onCanceled: (() -> Void)?

	public init(
		db: DB,
		navTitle: LocalizedStringKey = "",
		onSignedIn: @escaping () -> Void = {},
		onCanceled: (() -> Void)? = nil
	) {
		self._db = ObservedObject(wrappedValue: db)
		self.navTitle = navTitle
		self.onSignedIn = onSignedIn
		self.onCanceled = onCanceled

		var navPath = NavigationPath()

		if let user = db.currentUser {
			if db.currentUserProvider == .email,
				!user.isEmailVerified
			{
				navPath.append(SignInFlowPath.confirmEmail)
			} else {
				onSignedIn()
			}
		}

		self.signInFlowPath = navPath
	}

	public var body: some View {
		NavigationStack(path: $signInFlowPath) {
			ScrollView {
				VStack {
					SignInHeroSection()
						.padding(.bottom, 30)
						.padding(.top, currentPlatform == .pad ? 0 : 30)

					// If user is already signed in, show a small sign out button
					if db.currentUser != nil {
						HStack(spacing: 0) {
							Text(
								"You're already signed in.\(db.currentUser!.isEmailVerified ? "" : " (Unverified)") "
							)
							.foregroundStyle(.secondary)

							Button("Sign Out") {
								tryFunctionOtherwiseShowInAppNotification(
									fallbackNotificationContent: .init(
										title: "Sign Out Error",
										message: "Try Again Later")
								) {
									try db.signOut()
								}
							}
							Spacer()
						}
						.font(.caption)
					}

					EmailInputFields(
						forgotPasswordAction: {
							signInFlowPath.append(SignInFlowPath.forgotPassword)
						},
						continueAction: { email, password in
							Task {
								await tryFunctionOtherwiseShowInAppNotification(
									fallbackNotificationContent:
										.init(
											title: "Authorization Error",
											message: "Try Again Later"
										)
								) {
									try await db.signIn(email: email, password: password)
									showInAppNotification(
										.success,
										content: .init(
											title: "Successfully Signed In",
											message: "Enjoy!"
										),
										size: .compact
									)
								}
							}
						})

					HStack(spacing: 0) {
						VStack {
							Divider().background(.tertiary)
						}

						Text("OR")
							.padding(.horizontal, 30)
							.foregroundStyle(.tertiary)

						VStack {
							Divider().background(.tertiary)
						}
					}
					.padding(.vertical, 10)

					SignUpButtons(shouldShowEmailSignUpScreen: {
						signInFlowPath.append(SignInFlowPath.emailSignUp)
					})
				}

				.padding()
				.navigationTitle(navTitle)
				.navigationBarTitleDisplayMode(.inline)
				.navigationDestination(for: SignInFlowPath.self) { authScreen in
					switch authScreen {
						case .emailSignUp:
							SignUpView()
						case .confirmEmail:
							VerifyEmailView()
								// if the verify email view is shown, we dont want the user to be able to "simply go back"
								// what they can do is press on the "sign out" button, which will log them out and send them
								// back to the sign in view
								.navigationBarBackButtonHidden(true)
						case .forgotPassword:
							ForgotPasswordView {
								signInFlowPath.removeLast(signInFlowPath.count)
							}
							.navigationBarBackButtonHidden(true)
					}
				}
				.onChange(of: db.authState) {
					if let user = db.currentUser {
						if !user.isEmailVerified {
							signInFlowPath.append(SignInFlowPath.confirmEmail)
						} else {
							onSignedIn()
						}
					} else {
						signInFlowPath.removeLast(signInFlowPath.count)
					}
				}
				.toolbar {
					if let onCanceled = onCanceled {
						ToolbarItem(placement: .cancellationAction) {
							Button("Cancel", action: onCanceled)
						}
					}
				}
			}
		}
		.captureViewActivity(as: "SignInView")
	}
}

struct SignInHeroSection: View {
	var body: some View {
		VStack {
			Image(.appIconPreview)
				.resizable()
				.squircle(width: 150)
				.padding(.bottom, 10)

			Text(Constants.AppData.appName)
				.font(.largeTitle)
				.bold()

			Text(Constants.AppData.appDescription)
				.font(.callout)
				.multilineTextAlignment(.center)
				.foregroundStyle(.secondary)
		}
	}
}

private struct PreviewView: View {
	var body: some View {
		SignInView(db: DB())
	}
}

#Preview {
	Color.gray
		.sheet(isPresented: .constant(true)) {
			PreviewView()
		}
}
